/*#include "xhw_types.h"
 #include "xhw_ints.h"
 #include "xhw_nvic.h"
 #include "xhw_memmap.h"
 #include "xdebug.h"
 #include "xcore.h"
 #include "xsysctl.h"
 #include "xgpio.h"
 #include "xuart.h"*/

#include "stm32f10x.h"
#include "stm32f10x_gpio.h"
#include "stm32f10x_rcc.h"
#include "stm32f10x_usart.h"
#include "stm32f10x_exti.h"
#include "misc.h"

// OS
/* Scheduler includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "semphr.h"


#include "../system/src/stm32f1-stdperiph/stm32f10x_usart.c"

unsigned char ucData[] = "STM32F1xx.UART Example of CoX \r\n";

void busyLoop(unsigned long delay) {
	while (delay) {
		delay--;	// -O0 optimization
	}
}

#pragma GCC diagnostic ignored "-Wunused-parameter"

/* Initialize the LED (the board only has one). */
void init_led(void);

/* Configures the RS232 serial port using the following settings:
 *   9600 Baud
 *   8 bits + 1 stop bit
 *   No parity bit
 *   No hardware flow control
 * Note that the USART2 is not enabled in this routine.  It is left disabled in
 * case any additional configuration is needed.
 */
void init_rs232(void);

void enable_rs232_interrupts(void);

void enable_rs232(void);

void init_led(void) {
	GPIO_InitTypeDef GPIO_InitStructure;

	/* Enable GPIO C clock. */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);

	/* Set the LED pin state such that the LED is off.  The LED is connected
	 * between power and the microcontroller pin, which makes it turn on when
	 * the pin is low.
	 */
	GPIO_WriteBit(GPIOC, GPIO_Pin_12, Bit_SET);

	/* Configure the LED pin as push-pull output. */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOC, &GPIO_InitStructure);
}

void init_rs232(void)
{
    USART_InitTypeDef USART_InitStructure;
    GPIO_InitTypeDef GPIO_InitStructure;

    /* Enable peripheral clocks. */
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);

    /* Configure USART2 Rx pin as floating input. */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    /* Configure USART2 Tx as alternate function push-pull. */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    /* Configure the USART2 */
    USART_InitStructure.USART_BaudRate = 9600;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    USART_Init(USART2, &USART_InitStructure);
    USART_Cmd(USART2, ENABLE);
}

void enable_rs232_interrupts(void)
{
    NVIC_InitTypeDef NVIC_InitStructure;

    /* Enable transmit and receive interrupts for the USART2. */
    USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);

    /* Enable the USART2 IRQ in the NVIC module (so that the USART2 interrupt
     * handler is enabled). */
    NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);
}

void enable_rs232(void)
{
    /* Enable the RS232 port. */
    USART_Cmd(USART2, ENABLE);
}

void send_byte(uint8_t b)
{
    /* Wait until the RS232 port can receive another byte. */
    while(USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET);

    /* Toggle the LED just to show that progress is being made. */
    //GPIOC->ODR ^= 0x00001000;

    /* Send the byte */
    USART_SendData(USART2, b);
}

void GPIOA_Init(void)
{
    /* Bit configuration structure for GPIOA PIN8 */
    GPIO_InitTypeDef gpioa_init_struct = { GPIO_Pin_8, GPIO_Speed_50MHz,
                                           GPIO_Mode_Out_PP };

    /* Enable PORT A clock */
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    /* Initialize GPIOA: 50MHz, PIN8, Push-pull Output */
    GPIO_Init(GPIOA, &gpioa_init_struct);

    /* Turn off LED to start with */
    GPIO_SetBits(GPIOA, GPIO_Pin_8);
}

int main(int argc, char* argv[]) {

	SystemInit();

	// init_led();
	GPIOA_Init();



	init_rs232();
	enable_rs232_interrupts();
	enable_rs232();

	while (1) {
		/*GPIOC->BRR = 0x00001000;
		       busyLoop(500000);
		       GPIOC->BSRR = 0x00001000;
		       busyLoop(500000);*/

		send_byte('H');
		send_byte('e');
		send_byte('l');
		send_byte('l');
		send_byte('o');
		send_byte('\n');

		vTaskDelay(100);
	}

	/*unsigned long i;

	 // Not implemented in qemu...
	 // xSysCtlClockSet(16000000, xSYSCTL_OSC_MAIN | xSYSCTL_XTAL_25MHZ);

	 xSysCtlPeripheralEnable(xSYSCTL_PERIPH_GPIOC);
	 xSysCtlPeripheralEnable(xSYSCTL_PERIPH_GPIOA);

	 // uart
	 xSysCtlPeripheralEnable(xSYSCTL_PERIPH_GPIOD);
	 xSysCtlPeripheralEnable(SYSCTL_PERIPH_AFIO);

	 xSPinTypeUART(UART1TX, PA9);

	 xSysCtlPeripheralEnable(xSYSCTL_PERIPH_UART1);
	 xSysCtlPeripheralEnable(xSYSCTL_PERIPH_UART2);
	 xSysCtlPeripheralReset(xSYSCTL_PERIPH_UART2);
	 xSysCtlPeripheralEnable(xSYSCTL_PERIPH_UART2);

	 xUARTConfigSet(USART2_BASE, 115200, (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE | UART_CONFIG_PAR_NONE));

	 // xUARTEnable(USART1_BASE, (UART_BLOCK_UART | UART_BLOCK_TX | UART_BLOCK_RX));

	 /*for (i = 0; i < sizeof("STM32F1xx.UART Example of CoX \r\n"); i++) {
	 xUARTCharPut(USART1_BASE, ucData[i]);
	 }*

	 while(1);

	 // Set GPIO port C pin 12 as output
	 xGPIODirModeSet( xGPIO_PORTC_BASE, xGPIO_PIN_12, xGPIO_DIR_MODE_OUT);

	 // Set GPIO port A pin 0 as input
	 xGPIODirModeSet( xGPIO_PORTA_BASE, xGPIO_PIN_0, xGPIO_DIR_MODE_IN);

	 while (1) {
	 xGPIOPinWrite(xGPIO_PORTC_BASE, xGPIO_PIN_12, 1);

	 // Wait on button
	 while (!xGPIOPinRead(xGPIO_PORTA_BASE, xGPIO_PIN_0))
	 ;

	 while (1) {
	 busyLoop(50000000);
	 xGPIOPinWrite(xGPIO_PORTC_BASE, xGPIO_PIN_12, 1);
	 busyLoop(50000000);
	 xGPIOPinWrite(xGPIO_PORTC_BASE, xGPIO_PIN_12, 0);
	 }
	 }*/
}

void vApplicationTickHook( void )
{

}
